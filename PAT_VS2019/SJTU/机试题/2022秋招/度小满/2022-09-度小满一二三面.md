
## 2022-09-03-度小满一面-25min
周六

删除重复节点
```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        ListNode* h=new ListNode(0), *nn, *p, *t;
        h->next=pHead;
        p=h;
        while(p->next){
            nn=p->next->next;
            if(!nn)
                break;
            if(p->next->val!=nn->val){
                p=p->next;
            }else{
                int sameVal=p->next->val;
                while(p->next&&p->next->val==sameVal){
                    t=p->next;
                    p->next=t->next;
                    delete t;
                }
                t=nullptr;
            }
        }
        return h->next;
    }
};
```


## 2022-09-06-度小满二面-55min
https://shuiyuan.sjtu.edu.cn/t/topic/87013
https://www.nowcoder.com/discuss/1062438
问了很多都说不会，最后来个hard也不会，暴力过了10%

左右括号匹配，字符串里有些问号，问号可以是左括号可以是右括号，
每个问号改为每个符号的成本都不一样，问最小成本使得括号配对合法

```
#include <iostream>
#include <vector>
using namespace std;

// To execute C++, please define "int main()"

// The TestCase is shown below
// Input : 1 2
// Output : 3
vector<int> l,r;
int minCost,n;
string s,ansStr;
void dfs(int i, int lc, int pi, int cost){
	if(i==n){
		if(lc==0){
			if(minCost>cost){
				ansStr=s;
				minCost=cost;
			}
		}
		return ;
	}
	else if(cost>minCost)
		return;
	while(i<n){
		if(s[i]=='(') lc++;
		else if(s[i]==')'){
			lc--;
			if(lc<0) return;
		}else break;
	}

	if(i==n){
		if(lc==0){
			if(minCost>cost){
				ansStr=s;
				minCost=cost;
			}
		}
		return ;
	}
	
	++pi;
	//if(l[i]<r[i]){
		s[i]='(';
		dfs(i+1,lc+1,pi,l[pi]+cost);
	//}
	if(lc>0){
		s[i]=')';
		dfs(i+1,lc-1,pi,r[pi]+cost);
	}
	s[i]='?';
	return;
}

int main() {
	
	while(cin>>s){
		n=s.length();
		int q=0;
		for(auto& i:s){
			if(i=='?')
				q++;
		}
		l.resize(q,0);
		r.resize(q,0);
		for(int i=0;i<q;i++){
			cin>>l[i]>>r[i];
		}
		if(n%2==1)
		{
			cout<<-1<<endl;
			continue;
		}
		minCost=0x3fffffff;
		dfs(0,0,-1,0);
		cout<<minCost<<"\n"<<ansStr<<"\n";
		/*
		int lc=0, pi=-1;
		for(int i=0;i<n;i++){
			if(s[i]=='(')
				lc++;
			else if(s[i]==')')
				lc--;
			else{
				pi++;
				
			}
		}*/
	}
	
  	return 0;
}
```

以为会挂的，后收到了3面（9月17号），过了，10月约hr面


## 2022-09-17-度小满后端三面38min

没自我介绍，面的语言是啥，有跟你说具体面哪个部门的吗？
cpp，没有
第一个问题，引用和指针的区别，什么时候用引用什么时候用指针？
怎么查看内存、磁盘、网络连接数？
我说 ps -a | grep TCP，他当场特意要我发过去为我测了下，
我说有没有，他说没有。
没学过网络吗？
本科上过计网
不记得没关系，读研后来也没做了忘了正常
想做算法还是写代码做底层实现金融业务工程开发
os、算法、xx 熟悉哪块？
算法数据结构吧
挑一个说说看
......x几分钟
写点编程吧
随便挑一个数据结果实现，hashmap、队列、栈、链表、......都行
实现个队列吧
......
写好了（初始没扩容，当时也正在思考），代码也没要解释
你这个怎么扩容
......
那你尝试写一下吧
......
写了良久，说时间差不多了，你代码我也看了，（表示怀疑，在写原地扩容第二个版本了，却只字未提）
（故意不急不慢写到来催结束的，知道写不完，等对方先开口）
最后再问一个问题，你应该可以进各大厂，我这算不上大厂，对于最终意向怎么考虑，


```

template<class T>
class Queue{
    
private:
    T* a;
    int32_t size;
    int32_t capacity;
    int32_t first;
    int32_t end;
    
public:
    Queue(int32_t cap){
        size=0;
        capacity=cap+1;
        a=new T[cap];
        first=0;
        end=0;
    }
    
    bool push(T t){
        if(size==capacity-1)
            return false;
        a[end]=t;
        end = (end+1)%capacity;
        size++;
        return true;
    }
    
    T* front(){
        if(size==0)
            return NULL;
        return &a[first];
    }
    
    T* pop_front(){
        if(size==0)
            return NULL;
        T* front_ptr = &a[first];
        first = (first+1)%capacity;
        size--;
        return front_ptr;
    }
    
    bool resize(int32_t cap){
        if(cap<size) 
            return false;
        cap++;
        T* b = new T[cap];
        int32_t bi=0;
        while(first!=end){
            b[bi]=a[first];
            first=(first+1)%capacity;
        }
        first=0;
        end=size;
        delete a;
        a=b;
        b=NULL;
        return true;
        
        // v2
        realloc(a,sizeof(T)*cap);
        if(cap>capacity&&first>end){ // first<=end 时不需要调整
            int tailn = cap-capacity;
            int begini = capacity;
        }else if(cap<capacity){ // 容量减少
            if(first>=end){
                
            }else{

            }
        }
        return true;
    }
    
    ~Queue(){
        if(a){
            delete a;
            a=NULL;
        }
    }
};
```