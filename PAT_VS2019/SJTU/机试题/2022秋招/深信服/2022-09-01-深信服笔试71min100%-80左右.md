https://www.nowcoder.com/discuss/1036647

这回没有截图，抄了整整4页纸。
选择填空60分做了33分钟
编程第一题花了17min
第二题先8分钟随便写了个结果偷分90%，后6分钟改了下补上了10%
第三题 7分钟
和 [之江实验室](https://www.nowcoder.com/discuss/1033938) 还有 [度小满](https://www.nowcoder.com/discuss/1035251) 一样，每题还是优点难度的，能不能做出来都是碰运气罢了

# 不定选择 3’*10； -12

1. 容器有哪些：ABCD
A. array
B. list
C. hashtable
D. deque

只选了A -3
如果是问的C++11，hashtable不选

67%17=16

2. 选对的 （AB）
A. 执行态可以到就绪态
B. 就绪态可以到执行态
C. 就绪态可以到阻塞态
D. 阻塞态可以到创建态
 
-3

3. 输出什么
```
char c[]="abc\0def", *p=c;
printf("%c",*p+4);
```

e

4. (a|b)*c+[^0-9] 可以匹配出？

  A. abacc
  B. abac10
  C. c8
  D. adc

A -3
隐约记得 `^` 表示开头

5. [76 29 55 98 21 100 66] 二叉排序树的深度为？4

6. 崩溃还是输出
```
void test(char* p){
    p="abc";
}
char* p="test";
test(p);
printf("%s\n", p);
```

输出test
指针是拷贝不是引用，指向的值不会被修改
-3

7. 哪些值为true
```
int a=9876,b=9867;
printf("%d",!(b/a)); // A
printf("%d",!!(b/a*1.0));
printf("%d",!a||!b);
printf("%d",a&&b); // D
```
AD

# 填空 3*10‘；

1. 算了这么久居然还是算错了
```
    unsigned short int i=(unsigned short int)(-1234);
    printf("%hu\n",i);
```
不是64502，而是64302。

* 错误：-1234的二进制是 `1111 1100 0000 0000 + 1111 1111 1111 0110 = 1111 1011 1111 0110`，其10进制是 $2^{16}-1-2^{10}-8-1 = 64502$

* 正确：上面把-1234写成-1034了导致少减了200，最后多加了200
1234=0000 0100 1101 0010，
 -1234=1111 1011 0010 1110，
  
  $2^{16}-1-2^{10}-2^{7}-2^6-2^4-2^0=64302$

2. $\frac{20\%*60\%}{20\%*60\%+32\%*25\%+48\%*25\%}=37.50\%$

3. 字节流网络字节序编码是（大）端序

4. 取一个int里从最低有效位开始的第3个字节的值（a>>x1）&x2，其中x1、x2都是十进制。

  x1=16
  x2=255

5. 32位系统 x86
-3
```
struct stru{char c;int a;};

union uni{char c; int a;};

void f(struct stru a[2]){
    const char* str="hello";
    char str2[]="he";
    struct stru st={0};
    union uni un={0};
    std::cout<<sizeof(a)<<std::endl;    // 4
    std::cout<<sizeof(str)<<std::endl;  // 4
    std::cout<<sizeof(str2)<<std::endl; // 3
    std::cout<<sizeof("hello")<<std::endl; // 6
    std::cout<<sizeof(st)<<std::endl;   // 8
    std::cout<<sizeof(un)<<std::endl;   // 4
}
```

6. 2*9+5*（4+7/3）后序遍历：2 9 * 5 4 7 3 / + * +

7. a= , b=

```
    int a=5,b=6,w=1,x=2,y=3,z=4;
    (a=w>x)&&(b=y>z);
    std::cout<<a<<", "<<b;
```
 0 6

# 编程 10’+13‘+17’

## 1. 
题目：输入 n+1 个数，最后一个是 k，前 n 个数组成数组a。每次操作时判断a[0],a[1]大小，把大的放在下标0处，小的放到下标n-1处，当大的数在连续 k 次比较中都是大数时，操作结束，输出这个大数。

要求时间复杂度是 O（n），空间复杂度是O（1）。
> a: [2,1000]
> k: [1,999]

输入：
```
2 1 4 3 6 5 0 7 3
```

输出：
```
6
```

解释：
```
第一次操作得到：2 4 3 6 5 0 7 1
第二次操作得到：4 3 6 5 0 7 1 2 
第三次操作得到：4 6 5 0 7 1 2 3（4大了两回，小于k=3）
第四次操作得到：6 5 0 7 1 2 3 4
第五次操作得到：6 0 7 1 2 3 4 5
第六次操作得到：6 7 1 2 3 4 5 0（6大了三回，等于k=3，停止）
```

```
// 100% 10' 17min
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int n,k,t;
    vector<int> a;
    while(cin>>t)
        a.push_back(t);
    k=a.back();
    a.pop_back();
    n=a.size();
    int i=0;
    int h=0;
    t=a[0];
    while(i<n){
        int nexti=(i+1)%n;
        if(t>a[nexti]){
            h++;
//             cout<<"t= "<<t<<", a:"<<a[nexti]<<", h="<<h<<"\n";
            if(h==k){
                cout<<t;
                return 0;
            }
        }else if(t<a[nexti]){
            h=1;
            t=a[nexti];
//             cout<<"t="<<t<<"\n";
        }
        i=nexti;
    }
    return 0;
}
```

## 2.
输入一个数n表示数组长度，再输入n个无重复的数表示数组内容。
求最大排序连续上升子段的长度（某个连续子数组排序后两两之间只相差1）

> n: [1,5000]
> 每个数：[1,1e9]

输入： 
```
5
3 1 2 4 6
```
输出：`4`

解释：前四个数排序后是1234，两两相差1。

```
// // 13' 90% 8min
// #include<iostream>
// #include<vector>
// #include<unordered_set>
// using namespace std;

// int main(){
//     int n;cin>>n;
//     vector<int> a(n);
//     for(int i=0;i<n;i++)
//         cin>>a[i];
//     unordered_set<int> s;
//     s.insert(a[0]);
//     int maxl=1;
//     for(int i=1;i<n;i++){
//         if(!s.count(a[i])&&(s.count(a[i]-1)||s.count(a[i]+1)))
//            maxl=max(maxl,(int)s.size())+1;
//         s.insert(a[i]);
//     }
//     cout<<maxl;
//     return 0;
// }

// 13' 100% 6min
#include<iostream>
#include<vector>
#include<unordered_set>
using namespace std;

int main(){
    int n;cin>>n;
    vector<int> a(n);
    for(int i=0;i<n;i++)
        cin>>a[i];
    unordered_set<int> s;
    s.insert(a[0]);
    int maxl=1;
    for(int i=1;i<n;i++){
        if(!s.count(a[i])&&(s.count(a[i]-1)||s.count(a[i]+1)))
        {
//             maxl=max(maxl,(int)s.size())+1;
            int minv=a[i]-1,maxv=a[i]+1;
            while(s.count(minv))
                minv--;
            while(s.count(maxv))
                maxv++;
//             cout<<a[i]<<", "<<minv<<", "<<maxv<<"\n";
            maxl=max(maxl,maxv-minv-1);
        }
        s.insert(a[i]);
    }
    cout<<maxl;
    return 0;
}
```

据说是官方题解：
![图片说明](https://uploadfiles.nowcoder.com/images/20220901/793394141_1662036039057/42F06EFD0EDEC8EAF710A5956EF192F1 "图片标题") 

## 3. 病毒入侵
输入一个数 n，一个数 x，第二行输入 n 个数表示数组a。
病毒是一个数字v，病毒必须按顺序入侵数组a的每个元素。
如果 `|v-a[i]|<=x', 则病毒可以入侵成功a[i]。
病毒的值v可以任意变化，初始值页任意。
求病毒的值最少变化多少次，才可以按顺序入侵a的每个数。

> n: [1,100000]
> 1<=a[i],x<=1e9

输入：
```
5 4 
4 9 6 7 8
```

输出：`0`
初始值可以设为 5、6、7、8


```
// 17' 100% 7min
#include<iostream>
#include<vector>
#include<unordered_set>
using namespace std;

int main(){
    int n,x;cin>>n>>x;
    vector<int> a(n);
    for(int i=0;i<n;i++)
        cin>>a[i];
    int minv=a[0],maxv=a[0];
    int c=0;
    for(int i=1;i<n;i++){
        minv=min(minv,a[i]);
        maxv=max(maxv,a[i]);
        if(maxv-minv>2*x){
            c++;
            maxv=minv=a[i];
        }
    }
    cout<<c;
    return 0;
}
```
