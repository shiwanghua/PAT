10选择必须20分钟，记了3题
英语题打起来不用频繁切换中英文了

6选择+2编程26min，这块选择没什么好记的

1. Unit testing. which true 不定选 AEG?
A. 100% of all production code should be unit tested.
B. Unit testing is aimed at testing public interface of a class.
C. Unit testing should test the integration between key units in the code.
D. Unit tests should provide exhaustive coverage of inputs and outputs.
E. Unit tests should avoid dealing with external resources like databases or network I/O.
F. A good unit test only test a single permutation of inputs and outputs.
G. Unit tests should test all boundary conditions and corner cases.

2. which one is performance indicator in runtime (indicate the improvement of performance)
context switching, thrashing, virtual memory, critical section, dynamically allocating/releasing objects

3. read codes, what SOLID design principles does it violate.

4. What are some ways to make it easier to test a class/function/feature? 不定
A. Ensure that all class dependencies are passed into the class constructor.
B. reduce or eliminate a function's side effects?
C. Make a class's dependencies abstract (i.e. interfaces) instead of concrete implementations.
D. split larger classes into smaller ones.
E. Use a dynamic programming language.

​        BD ? A?

```cpp
// 1. 检查二叉搜索树中是否包含某个值
// 只需要实现isPresent
#include <bits/stdc++.h>

using namespace std;

class node 
{
    public:    
        int val;
        node * right, * left;
};

void insert(node ** tree, node * item)
{
        if(!(*tree))
        {
                *tree = item;
                return;
        }
        if(item->val<=(*tree)->val)
        {
                insert(&(*tree)->left, item);
        }

        else
        {
                insert(&(*tree)->right, item);
        }
}

int isPresent(node* root, int val){
/*
   The structure of the node is as follows:
      class node {
         public:
             node * left, *right;
             int val;
      };
*/
    while(root){
        if(root->val==val)return true;
        else if(root->val<val) root=root->right;
        else root=root->left;
    }
    return false;
}
int main() {
	node  * _root, * root_curr;
	int root_i=0, root_cnt = 0, root_num = 0;
	_root = NULL;
	cin >> root_cnt;
	for(root_i = 0; root_i < root_cnt; root_i++)
	{
		scanf("%d", &root_num);
		root_curr = (node *)malloc(sizeof(node));

		root_curr->left = root_curr->right = NULL;
		root_curr->val = root_num;

		insert(&_root, root_curr);
	}
	
    int q;
    cin >> q;
    
    while (q--) {
	   int _x; 
	   cin >> _x;
	   cout << isPresent(_root, _x) << endl;
    }
    
	return 0;
}

// 2. 求不超过某上限的最大连续子数组和
unsigned readUnsigned(bool wholeLine);
unsigned planCruise(unsigned n, unsigned b, unsigned p[]) {
    unsigned rb=0, maxrb=0;
    for(int i=0,j=0;i<n;i++){
        rb+=p[i];
        while(j<=i&&rb>b)
            rb-=p[j++];
        if(maxrb<rb)
            maxrb=rb;
    }
    return maxrb;
}
#include <cstdlib>
#include <fstream>
#include <iostream>

static_assert(sizeof(char) == 1);
static_assert(sizeof(int) == 4);
static_assert(sizeof(unsigned) == 4);
static_assert(sizeof(long long) == 8);

int main()
{    
    // Read in test case
    const unsigned numStops = readUnsigned(true);
    const unsigned budget = readUnsigned(true);
    unsigned *prices = new unsigned[numStops];
    for (auto i = 0; i < numStops; ++i) {
        prices[i] = readUnsigned(false);
    }
    
    // Execute function
    const auto result = planCruise(numStops, budget, prices);
    
    // Write output to file
    constexpr auto PATH_ENV_VAR = "OUTPUT_PATH";
    const auto outputPath = getenv(PATH_ENV_VAR);
    std::ofstream outfile(outputPath);
    outfile << result << std::endl;
    
    // Clean Up
    outfile.close();
    delete[] prices;
    
    // Return
    return 0;
}

unsigned readUnsigned(bool wholeLine) {
    unsigned value{};
    std::cin >> value;
    if (wholeLine) { std::cin >> std::ws; }
    return value;
}

```