1. 资源管理
(1)	C++的RAII机制是什么概念。
用于垃圾回收的机制，声明一个对象时调用其构造函数，退出一个对象的作用域时调用其析构函数，在析构函数里释放对象内部动态申请的内存，避免内存泄漏。

(2)	在std::中列出几个典型的使用了RAII机制的类。
unique_ptr, shared_ptr, vector

2. 内存管理
(1)	C++程序启动后一般有哪些内存区域？
从低地址到高地址依次是代码段、初始化的数据段、未初始化的数据段、堆、栈。

(2)	在这些区域中的对象，各自的生命周期是什么样？
前三个区域的生命周期贯穿于程序整个运行期间，堆上的对象可由程序员指定什么时候结束其生命周期，栈上的对象在退出其作用域时会调用其析构函数结束其生命周期。

(3)	智能指针是如何管理内存的，和Java等语言的垃圾回收对比，优势和劣势有什么？
unique_ptr 会把其拷贝构造函数、移动构造函数设为私有的或者删除的，从而使得外部无法共享其指向的数据；shared_ptr通过引用计数实现多个指针对同一块内存数据的共享，记录当前有多少个指针共享这块内存，只有当计数器为0了才会真正释放数据；weak_ptr 不影响引用计数，在获取数据时通过尝试转换为shared_ptr再获取数据。
和Java相比，优势是程序员可以主动管理内存，根据需要及时确定哪块内存需要被回收，按什么顺序回收内存，劣势是增加了程序中产生内存泄漏、数组越界和core dump的风险。

3. STL
(1)	STL的Iterator是什么概念？
是一种按迭代器设计模式设计的用于有序访问容器元素的功能。

(2)	和其他语言常见的，基于继承的迭代器相比，C++基于模板的有什么优势和劣势？
优势是增加了程序的可扩展性、通用性，代码的简洁性，劣势是需要include模板所在的整个头文件的代码，增加了不需要的逻辑，可能导致编译时间较长，代码的易读性不好，也不方便调试。

(3)	for (Item : Collection) 循环原理是什么？如果想要自定义的类支持，需要怎么做？
原理是调用Collection的迭代器来遍历处理它的每一个元素；对于自定义类，需实现iterator begin() 、iterator end() 、void operator++()、const T& operator*()、bool operator!=() 函数，通过begin获取指向第一个元素的迭代器，通过++指向下一个元素，通过*来对迭代器解引用，拿到它指向的元素，最后通过重载!=来判断是否处理到了end指向的位置，如果是就停止循环。

4. 自己实现一个std::optional类，只需要实现核心功能即可。

```
template <typename T>
class Optional
{
private:
    bool isNotNull;
    T data;

public:
    Optional() : isNotNull(false) {}

    Optional(const T &v)
    {
        data = v;
        isNotNull = true;
    }

    Optional(const Optional &v)
    {
        if (v.hasValue())
        {
            data = v.data;
            isNotNull = true;
        }
        else
        {
            isNotNull = false;
        }
    }

    ~Optional()
    {
        ((T *)&data)->~T();
    }

    bool hasValue() const { return isNotNull; }

    T &value()
    {
        return data;
    }

    T &operator*()
    {
        if (isNotNull)
            return data;
        else
            throw std::runtime_error("This optional has no value.");
    }

    operator bool() const
    {
        return isNotNull;
    }

    Optional &operator=(const Optional &v)
    {
        if (v.hasValue())
        {
            data = v.data;
            isNotNull = true;
        }
        else
        {
            isNotNull = false;
        }
        return *this;
    }

    bool operator==(const Optional<T> &v) const
    {
        if (isNotNull != v.hasValue())
            return false;
        else if (isNotNull)
            return data == v.data;
        else
            return true;
    }
};
```