24min+45min=69min

# 客观题 50'
1. a,b,c三个任务优先级递减，同时到达，都需按顺序执行 10msCPU，13msIO，5msCPU，从c到达到完成c需要54ms

2. -、*、\$优先级递减，左结合运算，\$指指数运算，`5-3*2$2*4-3$2=256`

3. 123入栈有5种出栈顺序

4. 仅当前类型能访问，用 private 关键字
仅当前程序集能访问，用internal
仅包含类或从包含类派生的类型能访问，用protected 

5. 
```
int c=0,x=8421;
while(x){c++;x=x&(x-1);}
```
c=6

6. i=0，两个线程分别执行`i++`100次后，i最大为200，最小为100

7. 高h的完全二叉树最少 $ 2^{h-1} $ 个节点，最多 $2^h-1$ 个节点；4000个节点组成的二叉树最小高度是12

# 问答题（不能切屏、文本框写）

10+10+10+20

1. 

```
// 1，1，2，3，5，8，13，21，34，递归求第30位数
#include<iostream>
#define ull unsigned long long
ull f(int i, const int end, ull a, ull b){
    if(i==end) return b;
    return f(i+1,end,b,a+b);
}
int main(){
    std::cout<<f(2,32,1ULL,1ULL)<<std::endl;
    return 0;
}
```

2. 

```cpp
// 不用基本加减乘除、不用额外空间，交换两个int的值

#include<iostream>
int main(){
    int32_t xy_num1;
    int32_t xy_num2;
    cin>>xy_num1>>xy_num2;
    xy_num1^=xy_num2;
    xy_num2^=xy_num1;
    xy_num1^=xy_num2;
    std::cout<<"xy_num1= "<<xy_num1<<", xy_num2"<<xy_num2<<std::endl;
    return 0;
}

```
3.
``` Java
private bool Is2Pow(int inputNumber){
    long cntOnes = inputNumber;
    cntOnes=cntOnes+(cntOnes>>1);
    cntOnes=cntOnes+(cntOnes>>2);
    cntOnes=cntOnes+(cntOnes>>4);
    cntOnes=cntOnes+(cntOnes>>8);
    cntOnes=cntOnes+(cntOnes>>16);
    if(cntOnes<2)return true;
    else return false;
}

```

4.

```C++
#include<vector>  
​
​typedef pair<int,int> pii
​​
​class PriorityQueue{
    vector<pii> v;
public:
    PriorityQueue(){
       v.resize(1); // 下标为0的元素占位
    }

  // 值越小优先级越高
  void push(int val, int priority){
​        int i=v.size();
        v.emplace_back({priority, val});
​       while(i>1){
​            int fi=v<<1;
​            if(v[fi].first<priority){
​                swap(v[fi],v[i]);
​                i=fi;
​            }else break;
​        }
  }

  // 出队优先级最高的元素
    int pop(){
​        if(v.size()==1) return -1; // null queue
      int topOne = v[1].second;
​        v[1]=v.back();
​        v.pop_back();
​        int i=1;
​        while(i<(int)v.size()){
​            int li = i<<1, ri=(i<<1)+1;
​            if(li<(int)v.size()){
​                if(ri<(int)v.size()&&v[ri].first>v[li].first){
​                    li=ri;
​                }
​                if(v[li].first>v[i].first){
​                    swap(v[li],v[i]);
​                }else break;
​            }
​            i=li;
​        }
​        return topOne;
  }

  bool empty(){
      return (int)v.size()==1;  
  }

  int size(){
        return (int)v.size()-1;
  }
};
```


第三题错了

int count(int num) {
    num = (num & 0x55555555) + ((num >> 1) & 0x55555555); // 相邻两位上的1的和存在这两位上
    num = (num & 0x33333333) + ((num >> 2) & 0x33333333); 
    num = (num & 0x0F0F0F0F) + ((num >> 4) & 0x0F0F0F0F);
    num = (num & 0x00FF00FF) + ((num >> 8) & 0x00FF00FF);
    num = (num & 0x0000FFFF) + ((num >> 16) & 0x0000FFFF);
    return num;
}