# 算法思路

### 1. B1007 Basic   求素数

* 埃式法
  * 从2开始遍历到n/2, 对每个数a，计算它们的倍数，得到的倍数全是非素数 
* 欧氏法 
  * 保存都有已知的素数，用i+1得到的新数从2开始乘以这些素数，得到的乘积是非素数，如果新数是某个素数的倍数就停止乘下去 b = k * a, 则大于a的素数 * b == a* (k*大于a的素数)  

### 2. B1008 数组元素循环右移m位 算法笔记P201

* 求m和n的最大公约数，从a[n-m]遍历到a[n-m+d-1]
* 每次遍历a[i]
  * pos=i, next=(pos-m+n)%n
  * 将 a[next] 放到 a[pos]，即往前数第m个元素放到本位置，
  * pos=next, 继续从a[pos]开始做类似移动，直到(pos-m+n)%n等于本轮循环的 i (已被覆盖）则将之前保存的a[i]值放到当前的a[pos]位置

### 3. A1101 P186

* 题目：找出数组中所有左边的数小于它，右边的数大于它的数
* 方法一：暴力解
  * 遍历每个数，比较它左边的数是否小于它，它右边的数是否大于它
  * 遇到否即停止比较，遍历下一个数
  * 如果满足题意即输出这个数
* 方法二：排序比较法
  * 复制数组a到数组b，对a排好序
  * 阻隔比较a与b相同位置 i 的数，并记录这个位置左边的数中的最大值max
  * 如果 a[i] 等于 b[i] 而且 b[i] 大于它左边的数字的最大值max，那么有**i**个数小于b[i], 符合题意，输出b[i]
* 方法三：数组记录法
  * 用数组maxl记录当前位置左边的数中的最大值，用数组minr记录当前位置右边的数中的最小值
  * 遍历原始数组a[i], 如果a[i]>maxl[i] 而且a[i]<minr[i]则输出a[i]