# 算法思路

### 1. B1007 Basic   求素数

* 埃式法
  * 从2开始遍历到n/2, 对每个数a，计算它们的倍数，得到的倍数全是非素数 
* 欧氏法 
  * 保存都有已知的素数，用i+1得到的新数从2开始乘以这些素数，得到的乘积是非素数，如果新数是某个素数的倍数就停止乘下去 b = k * a, 则大于a的素数 * b == a* (k*大于a的素数)  



### 2. B1008 数组元素循环右移m位 算法笔记P201

* 求m和n的最大公约数，从a[n-m]遍历到a[n-m+d-1]
* 每次遍历a[i]
  * pos=i, next=(pos-m+n)%n
  * 将 a[next] 放到 a[pos]，即往前数第m个元素放到本位置，
  * pos=next, 继续从a[pos]开始做类似移动，直到(pos-m+n)%n等于本轮循环的 i (已被覆盖）则将之前保存的a[i]值放到当前的a[pos]位置

