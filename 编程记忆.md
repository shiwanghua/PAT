# 编程记忆

### 1.scanf && cin

* %lld 对应long型变量         %d 对应 int

* 获取输入字符

  ```C++
  char c;
  getchar();  // 如果字符前有一个回车或一个空格就用getchar去掉,或者在前面加\n
  scanf(“%c”,&c);
  
  while((c=cin.get())!=EOF) map[c]++;
  ```

* 获取输入字符串

  ```c++
  // 方法一: 在PAT上没这个函数，在VS里可以
  char str[100];
  gets_s(str);// 可以读取空格，回车结束；gets没有了
  int N=strlen(str);
  
  // 方法二
  int num=0;
  char ans[90][90];
  while(scanf("%s",ans[num])!=EOF){num++;}// EOF为-1，num是单词个数
  
  //方法三
  #include<stack>
  stack<string> v;
  string s;
  while(cin>>s)v.push(s);
  cout<<v.pop();
  
  // 方法四
  string name;
  getline(cin,name); // 可读取空格
  
  // 方法五：scanf读入string, 本方法不建议使用，可能会输出多余空格
  string a; a.resize(20);
  scanf("%s",&a[0]);
  
  // 方法六
  char s1[10000];
  cin.getline(s1,10000);
  ```

* 循环获取输入，可直接while(cin>>a>>b){}

### 2. printf && cout

* %02d 输出2位整数，不足则以0填充，%010d, 输出10位整数不足则以0填充

* %.10f 输

  ```
  
  ```

  出10位float 或double型小数

* %s  输出一个char一维数组

  ```c++
  //printf输出string
  string str;cin>>str;
  printf("%s",str.c_str());
  ```

* cout填充与精度

```c++
int n=10;char a ='b';
cout<<setw(n)<<setfill(a)<<a;

int a=100; cout<<fixed<<setprecision(1)<<double(a); // 输出一位小数
```

* char a[11];  cin >> a;   **puts**(a);  // 即cout<<a;

### 3. string

* to_string

  ```c++
  int a=1; string s=to_string(a);
  cout << "0" + to_string(60);
  ```

* find

  ```c++
  #include <cctype>
  string s1, s2;
  cin >> s1 >> s2;
  if(s2.find(s1[0]) == string::npos);
  ```

* rbegin

  ```c++
  string n; cin>>n;//从后面遍历到前面
  for(auto it=n.rbegin();it!=n.rend();it++)
      cout<<*it;
  ```

  

### 4. fill

* 二维数组填充 

  int e\[501][501]; fill(e[0],e[0]+501*501, 123);

* 一维数组填充

  int dis[501]; fill(dis,dis+501,456);
  
* setfill()后面一定还要输出一个数据哪怕是一个空字符串！

```C++
int n=10;char a ='b';
cout<<setw(n)<<setfill(a)<<a;
```

* 字符串填充

  ```c++
  string a,b;cin>>a>>b;
  int lena=a.length(),lenb=b.length();
  if(lena>lenb) b.append(lena-lenb,'0'); // 往b的末尾补0直到与a等长
  else a.append(lenb-lena,'0');
  ```

* 

### 5. memcpy

* 复制数组a给b

  ```C++
  #include<string>
  memcpy(b,a,sizeof(int)*n);
  ```

### 6. struct

* 定义结构体时用了 typedef 的话，结构体定义完后的右括号后面声明的数组不可以用，去掉typedef就可以用那个结构数组了

### 7. vector + map

* 简单使用

```C++
vector<int> o;
o.push_back(123);
cout<<o[0];
cout<<o.size();
o.resize(8,100); // 将第2至第8个元素赋值为100
```

* 去重

  ```c++
  // 法1
  vector<char> con;
  sort(con.begin(), con.end());
  auto it = unique(con.begin(), con.end());
  con.erase(it, con.end()); // 删除重复元素
  con.erase(con.begin()); //  删除第一个元素
  
  // 法2 在插入时检测
  if (count(con.begin(), con.end(), a[i]) == 0)  // 如果不存在
  	con.push_back(a[i++]);
  ```
  
* map  A16

  ```c++
  map<string,vector<node>> custom;
  string s;cin>>str;
  vector<node> data(n); 
  //此处省略初始化data[0]
  custom[str].push_back(data[0]);
  
  // 方法1
  for(auto it:custom)
  {
      vector<node> temp=it.second;
      cout<<it.first;
  }
// 方法二
  map<string, vector<node>>::iterator it;
  for(it=custom.begin();it!=custom.end();it++)
  		 if(it->second==data[0]) cout << it->first <<"  ";
  //注： map用char*做映射和string做映射不同，用char*时每赋值一次就会多一个这样的同名映射而不会合并  见A95
  ```
  
* 二维

  ```c++
  vector<vector<int>> school(m);
  vector<int> school[m];
  ```

  

### 8. memset

* int c[10]; memset(c,0,40); // 只赋0和-1

### 9. isxxx

* isdigit(a[i])   //  a[i]是不是数字字符
* isalpha(c[j])  // c[j]是不是英文字母
* isupper(b[k])

### 10. stringstream  && substr  && stoi && toupper

* 获取子字符串并转数字（1）

  ```C++
  #include <iomanip> // PAT
  #include<sstream> // VS
  stringstream ss;
  ss<<s.substr(5);  // 取子字符串s[5]至s的结尾到容器ss中，
  int evalue;
  ss>>evalue; //转成数字
  ```

* 获取子字符串并转数字（2）

  ```c++
  string s; cin>>s;
  string t = s.substr(4,3); //获取子字符串s[4]开始长为3的字符串
  int n = stoi(s.substr(2));// 将s[2]至s的结尾的子字符串转化为数字，可含符号
  ```
  
* 小写转大写

  ```c++
  char a; cin >> a;
  cout << (char)toupper(a);
  ```

  

### 11. reverse

* 反转字符串

  ```c++
  string s;cin>>s;
  reverse(a.begin(),a.end());
  ```



### 12. sort

* 快速排序

  ```C++
  bool cmp(int a,int b) {return b>a;} // 降序
  vector<int> v;
  for(int i=0;i<100;i++)v.push_back(rand());
  sort(v.begin(),v.end(),cmp);
  for(int i=0;i<100;i++) cout<<v[i]<<" ";
  ```



### 13. strcmp

* int strcmp(const char* s1, const char* b); // s1<s2时返回负数，相等时返回0

  ```c++
  char a[10],c[4]="123";
  //三个a都会输出
  if(strcmp(a,c)==0) cout<<a;
  if(strcmp(a,"123")==0)cout<<a; 
  if(strcmp(a,"123\0")==0)cout<<a; 
  ```

  



### 14. round

* 四舍五入

  ```c++
  int a,b,c;cin>>a>>b>>c;
  a=round((a+b+c)/3.0)+0.5;
  ```




### 15. upper_bound

* 在数组a中查找第一个超过b的数的下标

  ```c++
  int j=upper_bound(a,a+n,b)-a;
  ```

  

### 其他

* long double 可用于 [−2<sup>63</sup>,2<sup>63</sup>]的加减法，只用double却不行，A1065

* ASCII 

  | **48-57**  | **0-9** |
  | ---------- | ------- |
  | **65-90**  | **A-Z** |
  | **97-122** | **a-z** |

* char数组赋值

  ```c++
  char s[14] = {"0123456789JQK"}; //数组长度不可以是c[13],但那下面这种可以是c[13]
  char c[14] = { '0','1','2','3','4','5','6','7','8','9','j','q','k' };
  ```

* 声明、初始化和释放string二维动态数组

```c++
int n,m; cin>>n>>m; // n行m列的string二维数组
string** ss=new string*[n];
for(int i=0;i<n;i++) ss[i]=new string[m];

// 赋值
string *q=ss[0];   // 1
string *w=*ss;     // 2
string *ww=*ss+2;  // 2
string s[5][6];
string(*e)[6]=s;   // 3 
int b[6]={0};
int *c=b;          // 4

for(int i=0;i<n;i++) delete[] ss[i];
delete[] ss;
```

* 
